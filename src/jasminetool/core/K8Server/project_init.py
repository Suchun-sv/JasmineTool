from jasminetool.config import JasmineConfig, RemoteK8sConfig

class ProjectInitializer:
    def __init__(self, global_config: JasmineConfig, server_config: RemoteK8sConfig):
        self.global_config = global_config
        self.server_config = server_config
    
    def _with_env_vars(self, cmd: str) -> str:
        base_cmd = cmd
        for env_var, env_value in self.global_config.env_vars.items():
            base_cmd = f'export {env_var}={env_value} && {base_cmd}'
        return base_cmd
    
    def _with_uv_xcmd_env(self, cmd: str) -> str:
        base_cmd = f'export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$HOME/.x-cmd.root/bin:$PATH" && {cmd} '
        for env_var, env_value in self.global_config.env_vars.items():
            base_cmd = f'export {env_var}={env_value} && {base_cmd}'
        return base_cmd

    def run(self, force: bool = True):
        """
        Generate complete bash script for project initialization
        Returns combined bash script as string
        """
        # Combine all bash scripts
        complete_script = f'''#!/bin/bash

# Project initialization script
# Generated by JasmineTool

{self._check_and_install_x_cmd()}

{self._check_and_install_uv()}

if [ {force} ]; then
    echo "Force mode is on, removing existing repository..."
    rm -rf {self.server_config.work_dir}
fi

{self._clone_repo()}

cd {self.server_config.work_dir}

# if install.sh exists, run it, else setup the environment
if [ -f "install.sh" ]; then
    echo "Running install.sh..."
    {self._with_env_vars("chmod +x install.sh && ./install.sh")}
else
    echo "install.sh does not exist, setting up environment..."
    {self._setup_environment()}
fi

echo "Project initialization completed"
'''
        return complete_script
    
    def generate_bash_file(self, output_path: str = "init_project.sh") -> str:
        """
        Generate bash file for project initialization
        Args:
            output_path: Path to save the bash file
        Returns:
            Path to the generated bash file
        """
        bash_script = self.run()
        
        with open(output_path, 'w') as f:
            f.write(bash_script)
        
        # Make the file executable
        import os
        os.chmod(output_path, 0o755)
        
        return output_path

    def _check_and_install_x_cmd(self) -> str:
        """
        Generate bash script to check and install x-cmd
        Returns bash script as string
        """
        bash_script = '''
# Check if x-cmd is installed
# If not, install x-cmd
# Return True if installed, False if not
check_xcmd() {
    if command -v x-cmd &> /dev/null; then
        echo "True"
        return 0
    else
        echo "Installing x-cmd..."
        # Install x-cmd
        eval "$(curl https://get.x-cmd.com)"
        export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$HOME/.x-cmd.root/bin:$PATH"
        
        # Check if installation was successful
        if command -v x-cmd &> /dev/null; then
            echo "True"  # Installation successful
            return 0
        else
            echo "False"  # Installation failed
            return 1
        fi
    fi
}

# Execute the check
check_xcmd
'''
        return bash_script

    def _check_and_install_uv(self) -> str:
        """
        Generate bash script to check and install uv
        Returns bash script as string
        """
        bash_script = '''
# Check if uv is installed
# If not, install uv
# Return True if installed, False if not
check_uv() {
    if command -v uv &> /dev/null; then
        echo "True"
        return 0
    else
        echo "Installing uv..."
        # Install uv
        curl -LsSf https://astral.sh/uv/install.sh | sh
        
        # Check if installation was successful
        if command -v uv &> /dev/null; then
            echo "True"  # Installation successful
            return 0
        else
            echo "False"  # Installation failed
            return 1
        fi
    fi
}

# Execute the check
check_uv
'''
        return bash_script

    def _setup_environment(self) -> str:
        """
        Generate bash script to setup Python environment
        Returns bash script as string
        """
        bash_script = f'''
# Setup Python environment
setup_environment() {{
    echo "Setting up Python environment..."
    
    # Navigate to work directory
    cd {self.server_config.work_dir}

    # Check if virtual environment exists
    if [ -d ".venv" ]; then
        echo "Virtual environment already exists"
        return 0
    fi

    # Create virtual environment using uv
    echo "Creating virtual environment with uv..."
    uv venv
    uv sync
    
    # Activate virtual environment
    source .venv/bin/activate
    
    # Install dependencies if requirements.txt exists
    if [ -f "requirements.txt" ]; then
        echo "Installing dependencies from requirements.txt..."
        uv pip install -r requirements.txt
    fi
    
    # Install dependencies if pyproject.toml exists
    if [ -f "pyproject.toml" ]; then
        echo "Installing dependencies from pyproject.toml..."
        uv pip install -e .
    fi
    
    echo "Environment setup completed"
    return 0
}}

# Execute environment setup
setup_environment
'''
        return bash_script
    
    def _generate_install_sh(self) -> str:
        """
        Generate install.sh script for project setup
        Returns install.sh script as string
        """
        install_script = f'''#!/bin/bash

# Install script for project setup
# Generated by JasmineTool

set -e  # Exit on any error

echo "ðŸš€ Starting project installation..."

# Step 1: Check and install x-cmd
{self._check_and_install_x_cmd()}

# Step 2: Check and install uv
{self._check_and_install_uv()}

# Step 3: Setup Python environment
{self._setup_environment()}

echo "âœ… Project installation completed successfully!"
'''
        return install_script
    
    def generate_install_sh_file(self, output_path: str = "install.sh") -> str:
        """
        Generate install.sh file for project setup
        Args:
            output_path: Path to save the install.sh file
        Returns:
            Path to the generated install.sh file
        """
        install_script = self._generate_install_sh()
        
        with open(output_path, 'w') as f:
            f.write(install_script)
        
        # Make the file executable
        import os
        os.chmod(output_path, 0o755)
        
        return output_path

    def _clone_repo(self) -> str:
        """
        Generate bash script to clone repository
        Returns bash script as string
        """
        bash_script = f'''
# Clone repository
clone_repo() {{
    if [ -d "{self.server_config.work_dir}" ]; then
        echo "Repository already exists at {self.server_config.work_dir}"
        return 0
    else
        echo "Cloning repository..."
        
        # Clone the repository
        export GITHUB_TOKEN=${self.global_config.env_vars["GITHUB_TOKEN"]} && git clone {self.server_config.github_url} {self.server_config.work_dir}
        
        # Check if clone was successful
        if [ -d "{self.server_config.work_dir}/.git" ]; then
            echo "True"  # Clone successful
            return 0
        else
            echo "False"  # Clone failed
            return 1
        fi
    fi
}}

# Execute the clone
clone_repo
'''
        return bash_script




